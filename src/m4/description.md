## 📊 Сравнение времени выполнения различных подходов

### Таблица времени выполнения

| № | Подход                              | Время выполнения (сек.) |
|---|-------------------------------------|--------------------------|
| 1 | `multiprocessing.Pool`              | 8.5956                   |
| 2 | `Process + Queue`                   | 27.6230                  |
| 3 | `ThreadPoolExecutor` (CPU-задача)   | 98.6909                  |

---

### График сравнения (в текстовом виде)

```
Время выполнения (сек.)
│
│ 100 ─────────────────────────────────────────░░░░░░░░░░─
│                                              ThreadPool
│  80 ────────────────────────────────────────────────────
│
│  60 ────────────────────────────────────────────────────
│
│  40 ────────────────────────████████────────────────────
│                               Queue
│  20 ───────████████─────────────────────────────────────
│              Pool
│   0 ────────────────────────────────────────────────────
│      Pool                     Queue          ThreadPool
```

---

### Выводы:

- `multiprocessing.Pool` — **самый эффективный** для CPU-интенсивных задач.
- `Process + Queue` — **работает**, но с **высокими накладными расходами**.
- `ThreadPoolExecutor` — **не подходит** для CPU-интенсивных задач в Python из-за GIL.

---